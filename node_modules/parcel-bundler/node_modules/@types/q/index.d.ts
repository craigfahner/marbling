// Type definitions for Q 1.5
// Project: https://github.com/kriskowal/q
// Definitions by: Barrie Nemetchek <https://github.com/bnemetchek>
//                 Andrew Gaspar <https://github.com/AndrewGaspar>
//                 John Reilly <https://github.com/johnnyreilly>
//                 Michel Boudreau <https://github.com/mboudreau>
//                 TeamworkGuy2 <https://github.com/TeamworkGuy2>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped
// TypeScript Version: 2.3

export = Q;
export as namespace Q;

/**
 * If value is a Q promise, returns the promise.
 * If value is a promise from another library it is coerced into a Q promise (where possible).
 * If value is not a promise, returns a promise that is fulfilled with value.
 */
declare function Q<T>(promise: PromiseLike<T> | T): Q.Promise<T>;
/**
 * Calling with nothing at all creates a void promise
 */
declare function Q(): Q.Promise<void>;

declare namespace Q {
    export type IWhenable<T> = PromiseLike<T> | T;
    export type IPromise<T> = PromiseLike<T>;

    export interface Deferred<T> {
        promise: Promise<T>;

        /**
         * Calling resolve with a pending promise causes promise to wait on the passed promise, becoming fulfilled with its
         * fulfillment value or rejected with its rejection reason (or staying pending forever, if the passed promise does).
         * Calling resolve with a rejected promise causes promise to be rejected with the passed promise's rejection reason.
         * Calling resolve with a fulfilled promise causes promise to be fulfilled with the passed promise's fulfillment value.
         * Calling resolve with a non-promise value causes promise to be fulfilled with that value.
         */
        resolve(value?: IWhenable<T>): void;

        /**
         * Calling reject with a reason causes promise to be rejected with that reason.
         */
        reject(reason?: any): void;

        /**
         * Calling notify with a value causes promise to be notified of progress with that value. That is, any onProgress
         * handlers registered with promise or promises derived from promise will be called with the progress value.
         */
        notify(value: any): void;

        /**
         * Returns a function suitable for passing to a Node.js API. That is, it has a signature (err, result) and will
         * reject deferred.promise with err if err is given, or fulfill it with result if that is given.
         */
        makeNodeResolver(): (reason: any, value: T) => void;
    }

    export interface Promise<T> {
        /**
         * The then method from the Promises/A+ specification, with an additional progress handler.
         */
        then<U>(onFulfill?: ((value: T) => IWhenable<U>) | null, onReject?: ((error: any) => IWhenable<U>) | null, onProgress?: ((progress: any) => any) | null): Promise<U>;
        then<U = T, V = never>(onFulfill?: ((value: T) => IWhenable<U>) | null, onReject?: ((error: any) => IWhenable<V>) | null, onProgress?: ((progress: any) => any) | null): Promise<U | V>;
        /**
         * Like a finally clause, allows you to observe either the fulfillment or rejection of a promise, but to do so
         * without modifying the final value. This is useful for collecting resources regardless of whether a job succeeded,
         * like closing a database connection, shutting a server down, or deleting an unneeded key from an object.
         * finally returns a promise, which will become resolved with the same fulfillment value or rejection reason
         * as promise. However, if callback returns a promise, the resolution of the returned promise will be delayed
         * until the promise returned from callback is finished. Furthermore, if the returned promise rejects, that
         * rejection will be passed down the chain instead of the previous result.
         */
        finally(finallyCallback: () => any): Promise<T>;

        /**
         * Alias for finally() (for non-ES5 browsers)
         */
        fin(finallyCallback: () => any): Promise<T>;

        /**
         * Like then, but "spreads" the array into a variadic fulfillment handler. If any of the promises in the array are
         * rejected, instead calls onRejected with the first rejected promise's rejection reason.
         * This is especially useful in conjunction with all
         */
        spread<U>(onFulfill: (...args: any[]) => IWhenable<U>, onReject?: (reason: any) => IWhenable<U>): Promise<U>;

        /**
         * A sugar method, equivalent to promise.then(undefined, onRejected).
         */
        catch<U>(onRejected: (reason: any) => IWhenable<U>): Promise<U>;

        /**
         * Alias for catch() (for non-ES5 browsers)
         */
        fail<U>(onRejected: (reason: any) => IWhenable<U>): Promise<U>;

        /**
         * A sugar method, equivalent to promise.then(undefined, undefined, onProgress).
         */
        progress(onProgress: (progress: any) => any): Promise<T>;

        /**
         * Much like then, but with different behavior around unhandled rejection. If there is an unhandled rejection,
         * either because promise is rejected and no onRejected callback was provided, or because onFulfilled or onRejected
         * threw an error or returned a rejected promise, the resulting rejection reason is thrown as an exception in a
         * future turn of the event loop.
         * This method should be used to terminate chains of promises that will not be passed elsewhere. Since exceptions
         * thrown in then callbacks are consumed and transformed into rejections, exceptions at the end of the chain are
         * easy to accidentally, silently ignore. By arranging for the exception to be thrown in a future turn of the
         * event loop, so that it won't be caught, it causes an onerror event on the browser window, or an uncaughtException
         * event on Node.js's process object.
         * Exceptions thrown by done will have long stack traces, if Q.longStackSupport is set to true. If Q.onerror is set,
         * exceptions will be delivered there instead of thrown in a future turn.
         * The Golden Rule of done vs. then usage is: either return your promise to someone else, or if the chain ends
         * with you, call done to terminate it. Terminating with catch is not sufficient because the catch handler may
         * itself throw an error.
         */
        done(onFulfilled?: ((value: T) => any) | null, onRejected?: ((reason: any) => any) | null, onProgress?: ((progress: any) => any) | null): void;

        /**
         * If callback is a function, assumes it's a Node.js-style callback, and calls it as either callback(rejectionReason)
         * when/if promise becomes rejected, or as callback(null, fulfillmentValue) when/if promise becomes fulfilled.
         * If callback is not a function, simply returns promise.
         */
        nodeify(callback: (reason: any, value: any) => void): Promise<T>;

        /**
         * Returns a promise to get the named property of an object. Essentially equivalent to
         *
         * @example
         * promise.then(function (o) { return o[propertyName]; });
         */
        get<U>(propertyName: string): Promise<U>;

        set<U>(propertyName: string, value: any): Promise<U>;

        delete<U>(propertyName: string): Promise<U>;

        /**
         * Returns a promise for the result of calling the named method of an object with the given array of arguments.
         * The object itself is this in the function, just like a synchronous method call. Essentially equivalent to
         *
         * @example
         * promise.then(function (o) { return o[methodName].apply(o, args); });
         */
        post<U>(methodName: string, args: any[]): Promise<U>;

        /**
         * Returns a promise for the result of calling the named method of an object with the given variadic arguments.
         * The object itself is this in the function, just like a synchronous method call.
         */
        invoke<U>(methodName: string, ...args: any[]): Promise<U>;

        /**
         * Returns a promise for an array of the property names of an object. Essentially equivalent to
         *
         * @example
         * promise.then(function (o) { return Object.keys(o); });
         */
        keys(): Promise<string[]>;

        /**
         * Returns a promise for the result of calling a function, with the given array of arguments. Essentially equivalent to
         *
         * @example
         * promise.then(function (f) {
         *     return f.apply(undefined, args);
         * });
         */
        fapply<U>(args: any[]): Promise<U>;

        /**
         * Returns a promise for the result of calling a function, with the given variadic arguments. Has the same return
         * value/thrown exception translation as explained above for fbind.
         * In its static form, it is aliased as Q.try, since it has semantics similar to a try block (but handling both
         * synchronous exceptions and asynchronous rejections). This allows code like
         *
         * @example
         * Q.try(function () {
         *     if (!isConnectedToCloud()) {
         *         throw new Error("The cloud is down!");
         *     }
         *     return syncToCloud();
         * })
         * .catch(function (error) {
         *     console.error("Couldn't sync to the cloud", error);
         * });
         */
        fcall<U>(...args: any[]): Promise<U>;

        /**
         * A sugar method, equivalent to promise.then(function () { return value; }).
         */
        thenResolve<U>(value: U): Promise<U>;

        /**
         * A sugar method, equivalent to promise.then(function () { throw reason; }).
         */
        thenReject<U = T>(reason?: any): Promise<U>;

        /**
         * Attaches a handler that will observe the value of the promise when it becomes fulfilled, returning a promise for
         * that same value, perhaps deferred but not replaced by the promise returned by the onFulfilled handler.
         */
        tap(onFulfilled: (value: T) => any): Promise<T>;

        /**
         * Returns a promise that will have the same result as promise, except that if promise is not fulfilled or rejected
         * before ms milliseconds, the returned promise will be rejected with an Error with the given message. If message
         * is not supplied, the message will be "Timed out after " + ms + " ms".
         */
        timeout(ms: number, message?: string): Promise<T>;

        /**
         * Returns a promise that will have the same result as promise, but will only be fulfilled or rejected after at least
         * ms milliseconds have passed.
         */
        delay(ms: number): Promise<T>;

        /**
         * Returns whether a given promise is in the fulfilled state. When the static version is used on non-promises, the
         * result is always true.
         */
        isFulfilled(): boolean;

        /**
         * Returns whether a given promise is in the rejected state. When the static version is used on non-promises, the
         * result is always false.
         */
        isRejected(): boolean;

        /**
         * Returns whether a given promise is in the pending state. When the static version is used on non-promises, the
         * result is always false.
         */
        isPending(): boolean;

        valueOf(): any;

        /**
         * Returns a "state snapshot" object, which will be in one of three forms:
         *
         * - { state: "pending" }
         * - { state: "fulfilled", value: <fulfllment value> }
         * - { state: "rejected", reason: <rejection reason> }
         */
        inspect(): PromiseState<T>;
    }

    export interface PromiseState<T> {
        state: "fulfilled" | "rejected" | "pending";
        value?: T;
        reason?: any;
    }

    /**
     * Returns a "deferred" object with a:
     * promise property
     * resolve(value) method
     * reject(reason) method
     * notify(value) method
     * makeNodeResolver() method
     */
    export function defer<T>(): Deferred<T>;

    /**
     * Calling resolve with a pending promise causes promise to wait on the passed promise, becoming fulfilled with its
     * fulfillment value or rejected with its rejection reason (or staying pending forever, if the passed promise does).
     * Calling resolve with a rejected promise causes promise to be rejected with the passed promise's rejection reason.
     * Calling resolve with a fulfilled promise causes promise to be fulfilled with the passed promise's fulfillment value.
     * Calling resolve with a non-promise value causes promise to be fulfilled with that value.
     */
    export function resolve<T>(object?: IWhenable<T>): Promise<T>;

    /**
     * Returns a promise that is rejected with reason.
     */
    export function reject<T>(reason?: any): Promise<T>;

    // If no value provided, returned promise will be of void type
    export function when(): Promise<void>;

    // if no fulfill, reject, or progress provided, returned promise will be of same type
    export function when<T>(value: IWhenable<T>): Promise<T>;

    // If a non-promise value is provided, it will not reject or progress
    export function when<T, U>(
        value: IWhenable<T>,
        onFulfilled: (val: T) => IWhenable<U>,
        onRejected?: ((reason: any) => IWhenable<U>) | null,
        onProgress?: ((progress: any) => any) | null
    ): Promise<U>;

    /**
     * (Deprecated) Returns a new function that calls a function asynchronously with the given variadic arguments, and returns a promise.
     * Notably, any synchronous return values or thrown exceptions are transformed, respectively, into fulfillment values
     * or rejection reasons for the promise returned by this new function.
     * This method is especially useful in its static form for wrapping functions to ensure that they are always
     * asynchronous, and that any thrown exceptions (intentional or accidental) are appropriately transformed into a
     * returned rejected promise. For example:
     *
     * @example
     * var getUserData = Q.fbind(function (userName) {
     *     if (!userName) {
     *         throw new Error("userName must be truthy!");
     *     }
     *     if (localCache.has(userName)) {
     *         return localCache.get(userName);
     *     }
     *     return getUserFromCloud(userName);
     * });
     */
    export function fbind<T>(method: (...args: any[]) => IWhenable<T>, ...args: any[]): (...args: any[]) => Promise<T>;

    /**
     * Returns a promise for the result of calling a function, with the given variadic arguments. Has the same return
     * value/thrown exception translation as explained above for fbind.
     * In its static form, it is aliased as Q.try, since it has semantics similar to a try block (but handling both synchronous
     * exceptions and asynchronous rejections). This allows code like
     *
     * @example
     * Q.try(function () {
     *     if (!isConnectedToCloud()) {
     *         throw new Error("The cloud is down!");
     *     }
     *     return syncToCloud();
     * })
     * .catch(function (error) {
     *     console.error("Couldn't sync to the cloud", error);
     * });
     */
    export function fcall<T>(method: (...args: any[]) => T, ...args: any[]): Promise<T>;

    // but 'try' is a reserved word.  This is the only way to get around this
    /**
     * Alias for fcall()
     */
    export { fcall as try };

    /**
     * Returns a promise for the result of calling the named method of an object with the given variadic arguments.
     * The object itself is this in the function, just like a synchronous method call.
     */
    export function invoke<T>(obj: any, functionName: string, ...args: any[]): Promise<T>;

    /**
     * Alias for invoke()
     */
    export function send<T>(obj: any, functionName: string, ...args: any[]): Promise<T>;

    /**
     * Alias for invoke()
     */
    export function mcall<T>(obj: any, functionName: string, ...args: any[]): Promise<T>;

    /**
     * Creates a promise-returning function from a Node.js-style function, optionally binding it with the given
     * variadic arguments. An example:
     *
     * @example
     * var readFile = Q.nfbind(FS.readFile);
     * readFile("foo.txt", "utf-8").done(function (text) {
     *     //...
     * });
     *
     * Note that if you have a method that uses the Node.js callback pattern, as opposed to just a function, you will
     * need to bind its this value before passing it to nfbind, like so:
     *
     * @example
     * var Kitty = mongoose.model("Kitty");
     * var findKitties = Q.nfbind(Kitty.find.bind(Kitty));
     *
     * The better strategy for methods would be to use Q.nbind, as shown below.
     */
    export function nfbind<T>(nodeFunction: (...args: any[]) => any, ...args: any[]): (...args: any[]) => Promise<T>;

    /**
     * Alias for nfbind()
     */
    export function denodeify<T>(nodeFunction: (...args: any[]) => any, ...args: any[]): (...args: any[]) => Promise<T>;

    /**
     * Creates a promise-returning function from a Node.js-style method, optionally binding it with the given
     * variadic arguments. An example:
     *
     * @example
     * var Kitty = mongoose.model("Kitty");
     * var findKitties = Q.nbind(Kitty.find, Kitty);
     * findKitties({ cute: true }).done(function (theKitties) {
     *     //...
     * });
     */
    export function nbind<T>(nodeFunction: (...args: any[]) => any, thisArg: any, ...args: any[]): (...args: any[]) => Promise<T>;

    /**
     * Calls a Node.js-style function with the given array of arguments, returning a promise that is fulfilled if the
     