# upath v1.2.0

[![Build Status](https://travis-ci.org/anodynos/upath.svg?branch=master)](https://travis-ci.org/anodynos/upath)
[![Up to date Status](https://david-dm.org/anodynos/upath.png)](https://david-dm.org/anodynos/upath)

A drop-in replacement / proxy to nodejs's `path` that:

  * Replaces the windows `\` with the unix `/` in all string params & results. This has significant positives - see below.

  * Adds **filename extensions** functions `addExt`, `trimExt`, `removeExt`, `changeExt`, and `defaultExt`.

  * Add a `normalizeSafe` function to preserve any meaningful leading `./` & a `normalizeTrim` which additionally trims any useless ending `/`.

  * Plus a helper `toUnix` that simply converts `\` to `/` and consolidates duplicates.

**Useful note: these docs are actually auto generated from [specs](https://github.com/anodynos/upath/blob/master/source/spec/upath-spec.coffee), running on Linux.**

Notes:

 * `upath.sep` is set to `'/'` for seamless replacement (as of 1.0.3).

 * upath has no runtime dependencies, except built-in `path` (as of 1.0.4)

 * travis-ci tested in node versions 4 to 12
      

## Why ?

Normal `path` doesn't convert paths to a unified format (ie `/`) before calculating paths (`normalize`, `join`), which can lead to numerous problems.
Also path joining, normalization etc on the two formats is not consistent, depending on where it runs. Running `path` on Windows yields different results than when it runs on Linux / Mac.

In general, if you code your paths logic while developing on Unix/Mac and it runs on Windows, you may run into problems when using `path`.

Note that using **Unix `/` on Windows** works perfectly inside nodejs (and other languages), so there's no reason to stick to the Windows legacy at all.

##### Examples / specs
        

Check out the different (improved) behavior to vanilla `path`:

    `upath.normalize(path)`        --returns-->

          ✓ `'c:/windows/nodejs/path'`           --->      `'c:/windows/nodejs/path'`  // equal to `path.normalize()`
          ✓ `'c:/windows/../nodejs/path'`        --->              `'c:/nodejs/path'`  // equal to `path.normalize()`
          ✓ `'c:\\windows\\nodejs\\path'`        --->      `'c:/windows/nodejs/path'`  // `path.normalize()` gives `'c:\windows\nodejs\path'`
          ✓ `'c:\\windows\\..\\nodejs\\path'`    --->              `'c:/nodejs/path'`  // `path.normalize()` gives `'c:\windows\..\nodejs\path'`
          ✓ `'//windows\\unix/mixed'`            --->         `'/windows/unix/mixed'`  // `path.normalize()` gives `'/windows\unix/mixed'`
          ✓ `'\\windows//unix/mixed'`            --->         `'/windows/unix/mixed'`  // `path.normalize()` gives `'\windows/unix/mixed'`
          ✓ `'////\\windows\\..\\unix/mixed/'`   --->                `'/unix/mixed/'`  // `path.normalize()` gives `'/\windows\..\unix/mixed/'`
        

Joining paths can also be a problem:

    `upath.join(paths...)`        --returns-->

          ✓ `'some/nodejs/deep', '../path'`       --->       `'some/nodejs/path'`  // equal to `path.join()`
          ✓ `'some/nodejs\\windows', '../path'`   --->       `'some/nodejs/path'`  // `path.join()` gives `'some/path'`
          ✓ `'some\\windows\\only', '..\\path'`   --->      `'some/windows/path'`  // `path.join()` gives `'some\windows\only/..\path'`
        

Parsing with `path.parse()` should also be consistent across OSes:

  `upath.parse(path)`        --returns-->

          ✓ `'c:\Windows\Directory\somefile.ext'`      ---> `{ root: '', dir: 'c:/Windows/Directory', base: 'somefile.ext', ext: '.ext', name: 'somefile' }`
                                    // `path.parse()` gives `'{ root: '', dir: '', base: 'c:\\Windows\\Directory\\somefile.ext', ext: '.ext', name: 'c:\\Windows\\Directory\\somefile' }'`
          ✓ `'/root/of/unix/somefile.ext'`             ---> `{ root: '/', dir: '/root/of/unix', base: 'somefile.ext', ext: '.ext', name: 'somefile' }`  // equal to `path.parse()`
    

## Added functions
      

#### `upath.toUnix(path)`

Just converts all `` to `/` and consolidates duplicates, without performing any normalization.

##### Examples / specs

    `upath.toUnix(path)`        --returns-->

        ✓ `'.//windows\//unix//mixed////'`      --->         `'./windows/unix/mixed/'`
        ✓ `'..///windows\..\\unix/mixed'`       --->      `'../windows/../unix/mixed'`
      

#### `upath.normalizeSafe(path)`

Exactly like `path.normalize(path)`, but it keeps the first meaningful `./`.

Note that the unix `/` is returned everywhere, so windows `\` is always converted to unix `/`.

##### Examples / specs & how it differs from vanilla `path`

    `upath.normalizeSafe(path)`        --returns-->

        ✓ `''`                               --->                          `'.'`  // equal to `path.normalize()`
        ✓ `'.'`                              --->                          `'.'`  // equal to `path.normalize()`
        ✓ `'./'`                             --->                         `'./'`  // equal to `path.normalize()`
        ✓ `'.//'`                            --->                         `'./'`  // equal to `path.normalize()`
        ✓ `'.\\'`                            --->                         `'./'`  // `path.normalize()` gives `'.\'`
        ✓ `'.\\//'`                          --->                         `'./'`  // `path.normalize()` gives `'.\/'`
        ✓ `'./..'`                           --->                         `'..'`  // equal to `path.normalize()`
        ✓ `'.//..'`                          --->                         `'..'`  // equal to `path.normalize()`
        ✓ `'./../'`                          --->                        `'../'`  // equal to `path.normalize()`
        ✓ `'.\\..\\'`                        --->                        `'../'`  // `path.normalize()` gives `'.\..\'`
        ✓ `'./../dep'`                       --->                     `'../dep'`  // equal to `path.normalize()`
        ✓ `'../dep'`                         --->                     `'../dep'`  // equal to `path.normalize()`
        ✓ `'../path/dep'`                    --->                `'../path/dep'`  // equal to `path.normalize()`
        ✓ `'../path/../dep'`                 --->                     `'../dep'`  // equal to `path.normalize()`
        ✓ `'dep'`                            --->                        `'dep'`  // equal to `path.normalize()`
        ✓ `'path//dep'`                      --->                   `'path/dep'`  // equal to `path.normalize()`
        ✓ `'./dep'`                          --->                      `'./dep'`  // `path.normalize()` gives `'dep'`
        ✓ `'./path/dep'`                     --->                 `'./path/dep'`  // `path.normalize()` gives `'path/dep'`
        ✓ `'./path/../dep'`                  --->                      `'./dep'`  // `path.normalize()` gives `'dep'`
        ✓ `'.//windows\\unix/mixed/'`        --->      `'./windows/unix/mixed/'`  // `path.normalize()` gives `'windows\unix/mixed/'`
        ✓ `'..//windows\\unix/mixed'`        --->      `'../windows/unix/mixed'`  // `path.normalize()` gives `'../windows\unix/mixed'`
        ✓ `'windows\\unix/mixed/'`           --->        `'windows/unix/mixed/'`  // `path.normalize()` gives `'windows\unix/mixed/'`
        ✓ `'..//windows\\..\\unix/mixed'`    --->              `'../unix/mixed'`  // `path.normalize()` gives `'../windows\..\unix/mixed'`
      

#### `upath.normalizeTrim(path)`

Exactly like `path.normalizeSafe(path)`, but it trims any useless ending `/`.

##### Examples / specs

    `upath.normalizeTrim(path)`        --returns-->

        ✓ `'./'`                          --->                         `'.'`  // `upath.normalizeSafe()` gives `'./'`
        ✓ `'./../'`                       --->                        `'..'`  // `upath.normalizeSafe()` gives `'../'`
        ✓ `'./../dep/'`                   --->                    `'../dep'`  // `upath.normalizeSafe()` gives `'../dep/'`
        ✓ `'path//dep\\'`                 --->                  `'path/dep'`  // `upath.normalizeSafe()` gives `'path/dep/'`
        ✓ `'.//windows\\unix/mixed/'`     --->      `'./windows/unix/mixed'`  // `upath.normalizeSafe()` gives `'./windows/unix/mixed/'`
      

#### `upath.joinSafe([path1][, path2][, ...])`

Exactly like `path.join()`, but it keeps the first meaningful `./`.

Note that the unix `/` is returned everywhere, so windows `\` is always converted to unix `/`.

##### Examples / specs & how it differs from vanilla `path`

    `upath.joinSafe(path)`        --returns-->

        ✓ `'some/nodejs/deep', '../path'`                --->           `'some/nodejs/path'`  // equal to `path.join()`
        ✓ `'./some/local/unix/', '../path'`              --->          `'./some/local/path'`  // `path.join()` gives `'some/local/path'`
        ✓ `'./some\\current\\mixed', '..\\path'`         --->        `'./some/current/path'`  // `path.join()` gives `'some\current\mixed/..\path'`
        ✓ `'../some/relative/destination', '..\\path'`   --->      `'../some/relative/path'`  // `path.join()` gives `'../some/relative/destination/..\path'`
    

## Added functions for *filename extension* manipulation.

**Happy notes:**

  In all functions you can:

  * use both `.ext` & `ext` - the dot `.` on the extension is always adjusted correctly.

  * omit the `ext` param (pass null/undefined/empty